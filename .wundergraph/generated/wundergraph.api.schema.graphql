# Code generated by "wunderctl"; DO NOT EDIT.

directive @fromClaim(name: Claim) on VARIABLE_DEFINITION

directive @hooksVariable on VARIABLE_DEFINITION

directive @jsonSchema(
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  title: String
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  description: String
  """
  The value of "multipleOf" MUST be a number, strictly greater than 0.
  
  A numeric instance is valid only if division by this keyword's value
  results in an integer.
  """
  multipleOf: Int
  """
  The value of "maximum" MUST be a number, representing an inclusive
  upper limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is less than or exactly equal to "maximum".
  """
  maximum: Int
  """
  The value of "exclusiveMaximum" MUST be number, representing an
  exclusive upper limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly less than (not equal to) "exclusiveMaximum".
  """
  exclusiveMaximum: Int
  """
  The value of "minimum" MUST be a number, representing an inclusive
  lower limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is greater than or exactly equal to "minimum".
  """
  minimum: Int
  """
  The value of "exclusiveMinimum" MUST be number, representing an
  exclusive lower limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly greater than (not equal to) "exclusiveMinimum".
  """
  exclusiveMinimum: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is less
  than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  """
  maxLength: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is
  greater than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minLength: Int
  """
  The value of this keyword MUST be a string.  This string SHOULD be a
  valid regular expression, according to the ECMA 262 regular
  expression dialect.
  
  A string instance is considered valid if the regular expression
  matches the instance successfully.  Recall: regular expressions are
  not implicitly anchored.
  """
  pattern: String
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "maxItems" if its size is less
  than, or equal to, the value of this keyword.
  """
  maxItems: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "minItems" if its size is greater
  than, or equal to, the value of this keyword.
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minItems: Int
  """
  The value of this keyword MUST be a boolean.
  
  If this keyword has boolean value false, the instance validates
  successfully.  If it has boolean value true, the instance validates
  successfully if all of its elements are unique.
  
  Omitting this keyword has the same behavior as a value of false.
  """
  uniqueItems: Boolean
  commonPattern: COMMON_REGEX_PATTERN
) on VARIABLE_DEFINITION

directive @rbac(
  """the user must match all roles"""
  requireMatchAll: [WG_ROLE]
  """the user must match at least one of the roles"""
  requireMatchAny: [WG_ROLE]
  """the user must not match all of the roles"""
  denyMatchAll: [WG_ROLE]
  """the user must not match any of the roles"""
  denyMatchAny: [WG_ROLE]
) on QUERY | MUTATION | SUBSCRIPTION

"""
The directive @injectCurrentDateTime injects a DateTime string of the current date and time into the variable.
This variable MUST be a string compatible scalar. 

The default format, is: ISO 8601
If no format is chosen, the default format is used.
Custom formats are allowed by specifying a format conforming to the Golang specification for specifying a date time format.
"""
directive @injectCurrentDateTime(
  format: WunderGraphDateTimeFormat = ISO8601
  """customFormat must conform to the Golang specification for specifying a date time format"""
  customFormat: String
) on VARIABLE_DEFINITION

"""
The directive @injectGeneratedUUID injects a generated UUID into the variable.
This variable MUST be a string.
At the same time, it removes the variable from the input definition,
disallowing the user to supply it.

This means, the UUID is 100% generated server-side and can be considered untempered.
"""
directive @injectGeneratedUUID on VARIABLE_DEFINITION

"""
The @internalOperation Directive marks an Operation as internal.
By doing so, the Operation is no longer accessible from the public API.
It can only be accessed by internal services, like hooks.
"""
directive @internalOperation on QUERY | MUTATION | SUBSCRIPTION

"""The directive @injectEnvironmentVariable allows you to inject an environment variable into the variable definition."""
directive @injectEnvironmentVariable(name: String!) on VARIABLE_DEFINITION

"""
The @export directive instructs the Execution Planner to export the field during the execution into the variable of the 'as' argument.
As the execution is depth first, a field can only be used after it has been exported.
Additionally, a field can only be used after using the '_join' field or on a different data source.
It's not possible to export a field and use it in for the same data source.

Note that the @export directive only works on fields that return a single value.
It's not possible to export a list or object field.
"""
directive @export(
  """The argument 'as' is the name of the variable to export the field to."""
  as: String!
) on FIELD

"""
The directive @internal marks a variable definition as internal so that clients can't access it.
The field is also not visible in the public API.
It's only being used as an internal variable to export fields into.
"""
directive @internal on VARIABLE_DEFINITION

"""
The @transform directive allows to apply transformations to the response.
By applying the directive, the shape of the response can be altered,
which will also modify the JSON-Schema of the response.
That is, you will keep full type safety and code-generation for transformed fields.
"""
directive @transform(
  """
  Using the 'get' transformation allows you to extract a nested field using a JSON path.
  This is useful to unnest data, e.g. when using the '_join' field, which adds an extra layer of nesting.
  
  Example:
  
  query GetName {
      name: me @transform(get: "info.name") {
          info {
              name
          }
      }
  }
  
  Before the transformation, the resolve looks like this:
  
  {
      "name": {
          "info": {
              "name": "John Doe"
          }
      }
  }
  
  With the transformation applied, the response will be reshaped like this:
  
  {
      "name": "John Doe"
  }
  """
  get: String
) on FIELD

type countries_Country {
  code: ID!
  name: String!
  native: String!
  phone: String!
  continent: countries_Continent!
  capital: String
  currency: String
  languages: [countries_Language!]!
  emoji: String!
  emojiU: String!
  states: [countries_State!]!
  _join: Query!
}

type countries_Continent {
  code: ID!
  name: String!
  countries: [countries_Country!]!
  _join: Query!
}

type countries_Language {
  code: ID!
  name: String
  native: String
  rtl: Boolean!
  _join: Query!
}

type countries_State {
  code: String
  name: String!
  country: countries_Country!
  _join: Query!
}

input countries_StringQueryOperatorInput {
  eq: String
  ne: String
  in: [String]
  nin: [String]
  regex: String
  glob: String
}

input countries_CountryFilterInput {
  code: countries_StringQueryOperatorInput
  currency: countries_StringQueryOperatorInput
  continent: countries_StringQueryOperatorInput
}

input countries_ContinentFilterInput {
  code: countries_StringQueryOperatorInput
}

input countries_LanguageFilterInput {
  code: countries_StringQueryOperatorInput
}

type Query {
  countries_countries(filter: countries_CountryFilterInput): [countries_Country!]!
  countries_country(code: ID!): countries_Country
  countries_continents(filter: countries_ContinentFilterInput): [countries_Continent!]!
  countries_continent(code: ID!): countries_Continent
  countries_languages(filter: countries_LanguageFilterInput): [countries_Language!]!
  countries_language(code: ID!): countries_Language
  db_findFirstmessages(where: db_messagesWhereInput, orderBy: [db_messagesOrderByWithRelationInput], cursor: db_messagesWhereUniqueInput, take: Int, skip: Int, distinct: [db_MessagesScalarFieldEnum]): db_messages
  db_findManymessages(where: db_messagesWhereInput, orderBy: [db_messagesOrderByWithRelationInput], cursor: db_messagesWhereUniqueInput, take: Int, skip: Int, distinct: [db_MessagesScalarFieldEnum]): [db_messages]!
  db_aggregatemessages(where: db_messagesWhereInput, orderBy: [db_messagesOrderByWithRelationInput], cursor: db_messagesWhereUniqueInput, take: Int, skip: Int): db_AggregateMessages!
  db_groupBymessages(where: db_messagesWhereInput, orderBy: [db_messagesOrderByWithAggregationInput], by: [db_MessagesScalarFieldEnum]!, having: db_messagesScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_MessagesGroupByOutputType]!
  db_findUniquemessages(where: db_messagesWhereUniqueInput!): db_messages
  db_findFirstusers(where: db_usersWhereInput, orderBy: [db_usersOrderByWithRelationInput], cursor: db_usersWhereUniqueInput, take: Int, skip: Int, distinct: [db_UsersScalarFieldEnum]): db_users
  db_findManyusers(where: db_usersWhereInput, orderBy: [db_usersOrderByWithRelationInput], cursor: db_usersWhereUniqueInput, take: Int, skip: Int, distinct: [db_UsersScalarFieldEnum]): [db_users]!
  db_aggregateusers(where: db_usersWhereInput, orderBy: [db_usersOrderByWithRelationInput], cursor: db_usersWhereUniqueInput, take: Int, skip: Int): db_AggregateUsers!
  db_groupByusers(where: db_usersWhereInput, orderBy: [db_usersOrderByWithAggregationInput], by: [db_UsersScalarFieldEnum]!, having: db_usersScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_UsersGroupByOutputType]!
  db_findUniqueusers(where: db_usersWhereUniqueInput!): db_users
}

input db_NestedIntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntFilter
}

input db_IntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntFilter
}

enum db_QueryMode {
  default
  insensitive
}

input db_NestedStringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringFilter
}

input db_StringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: db_QueryMode
  not: db_NestedStringFilter
}

input db_NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_DateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_MessagesListRelationFilter {
  every: db_messagesWhereInput
  some: db_messagesWhereInput
  none: db_messagesWhereInput
}

input db_usersWhereInput {
  AND: db_usersWhereInput
  OR: [db_usersWhereInput]
  NOT: db_usersWhereInput
  id: db_IntFilter
  email: db_StringFilter
  name: db_StringFilter
  updatedat: db_DateTimeFilter
  lastlogin: db_DateTimeFilter
  messages: db_MessagesListRelationFilter
}

input db_UsersRelationFilter {
  is: db_usersWhereInput
  isNot: db_usersWhereInput
}

input db_messagesWhereInput {
  AND: db_messagesWhereInput
  OR: [db_messagesWhereInput]
  NOT: db_messagesWhereInput
  id: db_IntFilter
  user_id: db_IntFilter
  message: db_StringFilter
  users: db_UsersRelationFilter
}

enum db_SortOrder {
  asc
  desc
}

input db_messagesOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_usersOrderByWithRelationInput {
  id: db_SortOrder
  email: db_SortOrder
  name: db_SortOrder
  updatedat: db_SortOrder
  lastlogin: db_SortOrder
  messages: db_messagesOrderByRelationAggregateInput
}

input db_messagesOrderByWithRelationInput {
  id: db_SortOrder
  user_id: db_SortOrder
  message: db_SortOrder
  users: db_usersOrderByWithRelationInput
}

input db_messagesWhereUniqueInput {
  id: Int
}

enum db_MessagesScalarFieldEnum {
  id
  user_id
  message
}

type db_UsersCountOutputType {
  messages: Int!
  _join: Query!
}

type db_users {
  id: Int!
  email: String!
  name: String!
  updatedat: DateTime!
  lastlogin: DateTime!
  messages(where: db_messagesWhereInput, orderBy: [db_messagesOrderByWithRelationInput], cursor: db_messagesWhereUniqueInput, take: Int, skip: Int, distinct: [db_MessagesScalarFieldEnum]): [db_messages]
  _count: db_UsersCountOutputType
  _join: Query!
}

type db_messages {
  id: Int!
  user_id: Int!
  message: String!
  users: db_users!
  _join: Query!
}

type db_MessagesCountAggregateOutputType {
  id: Int!
  user_id: Int!
  message: Int!
  _all: Int!
  _join: Query!
}

type db_MessagesAvgAggregateOutputType {
  id: Float
  user_id: Float
  _join: Query!
}

type db_MessagesSumAggregateOutputType {
  id: Int
  user_id: Int
  _join: Query!
}

type db_MessagesMinAggregateOutputType {
  id: Int
  user_id: Int
  message: String
  _join: Query!
}

type db_MessagesMaxAggregateOutputType {
  id: Int
  user_id: Int
  message: String
  _join: Query!
}

type db_AggregateMessages {
  _count: db_MessagesCountAggregateOutputType
  _avg: db_MessagesAvgAggregateOutputType
  _sum: db_MessagesSumAggregateOutputType
  _min: db_MessagesMinAggregateOutputType
  _max: db_MessagesMaxAggregateOutputType
  _join: Query!
}

input db_messagesCountOrderByAggregateInput {
  id: db_SortOrder
  user_id: db_SortOrder
  message: db_SortOrder
}

input db_messagesAvgOrderByAggregateInput {
  id: db_SortOrder
  user_id: db_SortOrder
}

input db_messagesMaxOrderByAggregateInput {
  id: db_SortOrder
  user_id: db_SortOrder
  message: db_SortOrder
}

input db_messagesMinOrderByAggregateInput {
  id: db_SortOrder
  user_id: db_SortOrder
  message: db_SortOrder
}

input db_messagesSumOrderByAggregateInput {
  id: db_SortOrder
  user_id: db_SortOrder
}

input db_messagesOrderByWithAggregationInput {
  id: db_SortOrder
  user_id: db_SortOrder
  message: db_SortOrder
  _count: db_messagesCountOrderByAggregateInput
  _avg: db_messagesAvgOrderByAggregateInput
  _max: db_messagesMaxOrderByAggregateInput
  _min: db_messagesMinOrderByAggregateInput
  _sum: db_messagesSumOrderByAggregateInput
}

input db_NestedFloatFilter {
  equals: Float
  in: [Float]
  notIn: [Float]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: db_NestedFloatFilter
}

input db_NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntWithAggregatesFilter
  _count: db_NestedIntFilter
  _avg: db_NestedFloatFilter
  _sum: db_NestedIntFilter
  _min: db_NestedIntFilter
  _max: db_NestedIntFilter
}

input db_IntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntWithAggregatesFilter
  _count: db_NestedIntFilter
  _avg: db_NestedFloatFilter
  _sum: db_NestedIntFilter
  _min: db_NestedIntFilter
  _max: db_NestedIntFilter
}

input db_NestedStringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_StringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: db_QueryMode
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_messagesScalarWhereWithAggregatesInput {
  AND: db_messagesScalarWhereWithAggregatesInput
  OR: [db_messagesScalarWhereWithAggregatesInput]
  NOT: db_messagesScalarWhereWithAggregatesInput
  id: db_IntWithAggregatesFilter
  user_id: db_IntWithAggregatesFilter
  message: db_StringWithAggregatesFilter
}

type db_MessagesGroupByOutputType {
  id: Int!
  user_id: Int!
  message: String!
  _count: db_MessagesCountAggregateOutputType
  _avg: db_MessagesAvgAggregateOutputType
  _sum: db_MessagesSumAggregateOutputType
  _min: db_MessagesMinAggregateOutputType
  _max: db_MessagesMaxAggregateOutputType
  _join: Query!
}

input db_usersWhereUniqueInput {
  id: Int
  email: String
}

enum db_UsersScalarFieldEnum {
  id
  email
  name
  updatedat
  lastlogin
}

type db_UsersCountAggregateOutputType {
  id: Int!
  email: Int!
  name: Int!
  updatedat: Int!
  lastlogin: Int!
  _all: Int!
  _join: Query!
}

type db_UsersAvgAggregateOutputType {
  id: Float
  _join: Query!
}

type db_UsersSumAggregateOutputType {
  id: Int
  _join: Query!
}

type db_UsersMinAggregateOutputType {
  id: Int
  email: String
  name: String
  updatedat: DateTime
  lastlogin: DateTime
  _join: Query!
}

type db_UsersMaxAggregateOutputType {
  id: Int
  email: String
  name: String
  updatedat: DateTime
  lastlogin: DateTime
  _join: Query!
}

type db_AggregateUsers {
  _count: db_UsersCountAggregateOutputType
  _avg: db_UsersAvgAggregateOutputType
  _sum: db_UsersSumAggregateOutputType
  _min: db_UsersMinAggregateOutputType
  _max: db_UsersMaxAggregateOutputType
  _join: Query!
}

input db_usersCountOrderByAggregateInput {
  id: db_SortOrder
  email: db_SortOrder
  name: db_SortOrder
  updatedat: db_SortOrder
  lastlogin: db_SortOrder
}

input db_usersAvgOrderByAggregateInput {
  id: db_SortOrder
}

input db_usersMaxOrderByAggregateInput {
  id: db_SortOrder
  email: db_SortOrder
  name: db_SortOrder
  updatedat: db_SortOrder
  lastlogin: db_SortOrder
}

input db_usersMinOrderByAggregateInput {
  id: db_SortOrder
  email: db_SortOrder
  name: db_SortOrder
  updatedat: db_SortOrder
  lastlogin: db_SortOrder
}

input db_usersSumOrderByAggregateInput {
  id: db_SortOrder
}

input db_usersOrderByWithAggregationInput {
  id: db_SortOrder
  email: db_SortOrder
  name: db_SortOrder
  updatedat: db_SortOrder
  lastlogin: db_SortOrder
  _count: db_usersCountOrderByAggregateInput
  _avg: db_usersAvgOrderByAggregateInput
  _max: db_usersMaxOrderByAggregateInput
  _min: db_usersMinOrderByAggregateInput
  _sum: db_usersSumOrderByAggregateInput
}

input db_NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_usersScalarWhereWithAggregatesInput {
  AND: db_usersScalarWhereWithAggregatesInput
  OR: [db_usersScalarWhereWithAggregatesInput]
  NOT: db_usersScalarWhereWithAggregatesInput
  id: db_IntWithAggregatesFilter
  email: db_StringWithAggregatesFilter
  name: db_StringWithAggregatesFilter
  updatedat: db_DateTimeWithAggregatesFilter
  lastlogin: db_DateTimeWithAggregatesFilter
}

type db_UsersGroupByOutputType {
  id: Int!
  email: String!
  name: String!
  updatedat: DateTime!
  lastlogin: DateTime!
  _count: db_UsersCountAggregateOutputType
  _avg: db_UsersAvgAggregateOutputType
  _sum: db_UsersSumAggregateOutputType
  _min: db_UsersMinAggregateOutputType
  _max: db_UsersMaxAggregateOutputType
  _join: Query!
}

input db_usersCreateWithoutMessagesInput {
  email: String!
  name: String!
  updatedat: DateTime
  lastlogin: DateTime
}

input db_usersCreateOrConnectWithoutMessagesInput {
  where: db_usersWhereUniqueInput!
  create: db_usersCreateWithoutMessagesInput!
}

input db_usersCreateNestedOneWithoutMessagesInput {
  create: db_usersCreateWithoutMessagesInput
  connectOrCreate: db_usersCreateOrConnectWithoutMessagesInput
  connect: db_usersWhereUniqueInput
}

input db_messagesCreateInput {
  message: String!
  users: db_usersCreateNestedOneWithoutMessagesInput!
}

input db_StringFieldUpdateOperationsInput {
  set: String
}

input db_DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input db_usersUpdateWithoutMessagesInput {
  email: db_StringFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  updatedat: db_DateTimeFieldUpdateOperationsInput
  lastlogin: db_DateTimeFieldUpdateOperationsInput
}

input db_usersUpsertWithoutMessagesInput {
  update: db_usersUpdateWithoutMessagesInput!
  create: db_usersCreateWithoutMessagesInput!
}

input db_usersUpdateOneRequiredWithoutMessagesInput {
  create: db_usersCreateWithoutMessagesInput
  connectOrCreate: db_usersCreateOrConnectWithoutMessagesInput
  upsert: db_usersUpsertWithoutMessagesInput
  connect: db_usersWhereUniqueInput
  update: db_usersUpdateWithoutMessagesInput
}

input db_messagesUpdateInput {
  message: db_StringFieldUpdateOperationsInput
  users: db_usersUpdateOneRequiredWithoutMessagesInput
}

input db_messagesCreateManyInput {
  id: Int
  user_id: Int!
  message: String!
}

type db_AffectedRowsOutput {
  count: Int!
  _join: Query!
}

input db_messagesUpdateManyMutationInput {
  message: db_StringFieldUpdateOperationsInput
}

input db_messagesCreateWithoutUsersInput {
  message: String!
}

input db_messagesCreateOrConnectWithoutUsersInput {
  where: db_messagesWhereUniqueInput!
  create: [db_messagesCreateWithoutUsersInput!]
}

input db_messagesCreateManyUsersInput {
  id: Int
  message: String!
}

input db_messagesCreateManyUsersInputEnvelope {
  data: [db_messagesCreateManyUsersInput]!
  skipDuplicates: Boolean
}

input db_messagesCreateNestedManyWithoutUsersInput {
  create: [db_messagesCreateWithoutUsersInput]
  connectOrCreate: [db_messagesCreateOrConnectWithoutUsersInput]
  createMany: [db_messagesCreateManyUsersInputEnvelope]
  connect: [db_messagesWhereUniqueInput]
}

input db_usersCreateInput {
  email: String!
  name: String!
  updatedat: DateTime
  lastlogin: DateTime
  messages: db_messagesCreateNestedManyWithoutUsersInput
}

input db_messagesUpdateWithoutUsersInput {
  message: db_StringFieldUpdateOperationsInput
}

input db_messagesUpsertWithWhereUniqueWithoutUsersInput {
  where: db_messagesWhereUniqueInput!
  update: [db_messagesUpdateWithoutUsersInput!]
  create: [db_messagesCreateWithoutUsersInput!]
}

input db_messagesUpdateWithWhereUniqueWithoutUsersInput {
  where: db_messagesWhereUniqueInput!
  data: db_messagesUpdateWithoutUsersInput!
}

input db_messagesScalarWhereInput {
  AND: db_messagesScalarWhereInput
  OR: [db_messagesScalarWhereInput]
  NOT: db_messagesScalarWhereInput
  id: db_IntFilter
  user_id: db_IntFilter
  message: db_StringFilter
}

input db_messagesUpdateManyWithWhereWithoutUsersInput {
  where: db_messagesScalarWhereInput!
  data: db_messagesUpdateManyMutationInput!
}

input db_messagesUpdateManyWithoutUsersInput {
  create: [db_messagesCreateWithoutUsersInput]
  connectOrCreate: [db_messagesCreateOrConnectWithoutUsersInput]
  upsert: [db_messagesUpsertWithWhereUniqueWithoutUsersInput]
  createMany: [db_messagesCreateManyUsersInputEnvelope]
  connect: [db_messagesWhereUniqueInput]
  set: db_messagesWhereUniqueInput
  disconnect: [db_messagesWhereUniqueInput]
  delete: [db_messagesWhereUniqueInput]
  update: [db_messagesUpdateWithWhereUniqueWithoutUsersInput]
  updateMany: [db_messagesUpdateManyWithWhereWithoutUsersInput]
  deleteMany: db_messagesScalarWhereInput
}

input db_usersUpdateInput {
  email: db_StringFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  updatedat: db_DateTimeFieldUpdateOperationsInput
  lastlogin: db_DateTimeFieldUpdateOperationsInput
  messages: db_messagesUpdateManyWithoutUsersInput
}

input db_usersCreateManyInput {
  id: Int
  email: String!
  name: String!
  updatedat: DateTime
  lastlogin: DateTime
}

input db_usersUpdateManyMutationInput {
  email: db_StringFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  updatedat: db_DateTimeFieldUpdateOperationsInput
  lastlogin: db_DateTimeFieldUpdateOperationsInput
}

type Mutation {
  db_createOnemessages(data: db_messagesCreateInput!): db_messages
  db_upsertOnemessages(where: db_messagesWhereUniqueInput!, create: db_messagesCreateInput!, update: db_messagesUpdateInput!): db_messages
  db_createManymessages(data: [db_messagesCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOnemessages(where: db_messagesWhereUniqueInput!): db_messages
  db_updateOnemessages(data: db_messagesUpdateInput!, where: db_messagesWhereUniqueInput!): db_messages
  db_updateManymessages(data: db_messagesUpdateManyMutationInput!, where: db_messagesWhereInput): db_AffectedRowsOutput
  db_deleteManymessages(where: db_messagesWhereInput): db_AffectedRowsOutput
  db_createOneusers(data: db_usersCreateInput!): db_users
  db_upsertOneusers(where: db_usersWhereUniqueInput!, create: db_usersCreateInput!, update: db_usersUpdateInput!): db_users
  db_createManyusers(data: [db_usersCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOneusers(where: db_usersWhereUniqueInput!): db_users
  db_updateOneusers(data: db_usersUpdateInput!, where: db_usersWhereUniqueInput!): db_users
  db_updateManyusers(data: db_usersUpdateManyMutationInput!, where: db_usersWhereInput): db_AffectedRowsOutput
  db_deleteManyusers(where: db_usersWhereInput): db_AffectedRowsOutput
}

scalar DateTime

scalar JSON

scalar UUID

scalar BigInt

enum Claim {
  EMAIL
  EMAIL_VERIFIED
  NAME
  NICKNAME
  LOCATION
  PROVIDER
}

enum COMMON_REGEX_PATTERN {
  EMAIL
  DOMAIN
}

enum WG_ROLE {
  user
  superadmin
}

enum WunderGraphDateTimeFormat {
  """2006-01-02T15:04:05-0700"""
  ISO8601
  """Mon Jan _2 15:04:05 2006"""
  ANSIC
  """Mon Jan _2 15:04:05 MST 2006"""
  UnixDate
  """Mon Jan 02 15:04:05 -0700 2006"""
  RubyDate
  """02 Jan 06 15:04 MST"""
  RFC822
  """02 Jan 06 15:04 -0700"""
  RFC822Z
  """Monday, 02-Jan-06 15:04:05 MST"""
  RFC850
  """Mon, 02 Jan 2006 15:04:05 MST"""
  RFC1123
  """Mon, 02 Jan 2006 15:04:05 -0700"""
  RFC1123Z
  """2006-01-02T15:04:05Z07:00"""
  RFC3339
  """2006-01-02T15:04:05.999999999Z07:00"""
  RFC3339Nano
  """3:04PM"""
  Kitchen
  """Jan _2 15:04:05"""
  Stamp
  """Jan _2 15:04:05.000"""
  StampMilli
  """Jan _2 15:04:05.000000"""
  StampMicro
  """Jan _2 15:04:05.000000000"""
  StampNano
}
